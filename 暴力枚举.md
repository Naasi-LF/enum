## 三.枚举!很暴力

### 1.坑爹的奥数

***例题***:

* 一道奥数题,`[]3*6528=3[]*8256`,在`[]`中写入**相同的数字**,使**等式**成立

  **代码实现**：

  ```c
  int main()
  {
      for(int i=1;i<=9;i++)
      {
          if ((i*10+3)*6528==(30+i)*8256)
          {
              printf("%d ",i);
          }
      }
  }
  ```

  **枚举**的**本质**:**有序**的尝试每一种**可能**

* `[][][]+[][][]=[][][]`,将`1~9`填入这**九个**格子,使得等式成立,每个数字**只能使用一次**

  **注**:`173+286=459,286+173=459`是**同一种**

  **代码实现**

  ```c
  #include<stdio.h>
  #include<stdlib.h>
  /*
  [a][b][c]+[d][e][f]=[g][h][i]
  */
  int main()
  {
      int a,b,c,d,e,f,g,h,i;//意义参考上面注释
      int n=9;//一共9个数
      int total=0;//计数
      for(int a=1;a<=n;a++)
      for(int b=1;b<=n;b++)
      for(int c=1;c<=n;c++)
      for(int d=1;d<=n;d++)
      for(int e=1;e<=n;e++)
      for(int f=1;f<=n;f++)
      for(int g=1;g<=n;g++)
      for(int h=1;h<=n;h++)
      for(int i=1;i<=n;i++)
      {
          //判断条件
          if(a*100+b*10+c+d*100+e*10+f==g*100+h*10+i)
          {
              if //注意，每个数互不相等
              ((a==b) || (a==c) || (a==d) || (a==e) || (a==f) || (a==g) || (a==h) || (a==i) || 
                (b==c) || (b==d) || (b==e) || (b==f) || (b==g) || (b==h) || (b==i) ||
                 (c==d) || (c==e) || (c==f) || (c==g) || (c==h) || (c==i) ||
                  (d==e) || (d==f) || (d==g) || (d==h) || (d==i) ||
                   (e==f) || (e==g) || (e==h) || (e==i) ||
                    (f==g) || (f==h) || (f==i) ||
                     (g==h) || (g==i) ||
                      (h==i))
              continue;
              else
              {
                  total++;
                  printf("%d%d%d+%d%d%d=%d%d%d\n",a,b,c,d,e,f,g,h,i);
              }
          }
      }
      total/=2;//减去重复部分
      printf("%d",total);
      return 0;
  }
  ```


### 2. 数的全排列

* `1 2 3 `的全排列为`123 132 213 231 312 321`,那么`1 2 3 4`的全排列为?

* **方法**:定义**个,十,百,千**四位,用`1~4`的数进行遍历,删去**重复部分**

  |  百  |  十  |  个  | 是否删去 |
  | :--: | :--: | :--: | :------: |
  |  1   |  1   |  1   |   删去   |
  |  1   |  1   |  2   |   删去   |
  |  1   |  1   |  3   |   删去   |
  |  1   |  2   |  1   |   删去   |
  |  1   |  2   |  2   |   删去   |
  |  1   |  2   |  3   |  1 2 3   |
  |  1   |  3   |  1   |   删去   |
  |  1   |  3   |  2   |  1 3 2   |
  |  1   |  3   |  3   |   删去   |
  |  2   |  1   |  1   |   删去   |
  |  2   |  1   |  2   |   删去   |
  |  2   |  1   |  3   |  2 1 3   |
  |  2   |  2   |  1   |   删去   |
  |  2   |  2   |  2   |   删去   |
  |  2   |  2   |  3   |   删去   |
  |  2   |  3   |  1   |  2 3 1   |
  |  2   |  3   |  2   |   删去   |
  |  2   |  3   |  3   |   删去   |
  |  3   |  1   |  1   |   删去   |
  |  3   |  1   |  2   |  3 2 1   |
  |  3   |  1   |  3   |   删去   |
  |  3   |  2   |  1   |  3 2 1   |
  |  3   |  2   |  2   |   删去   |
  |  3   |  2   |  3   |   删去   |
  |  3   |  3   |  1   |   删去   |
  |  3   |  3   |  2   |   删去   |
  |  3   |  3   |  3   |   删去   |

* **具体代码**

  ```c
  #include<stdio.h>
  #include<stdlib.h>
  int main()
  {
      //123 全排列
      int n=3;
      printf("1,2,3的全排列为:\n");
      for(int a=1;a<=n;a++)
        for(int b=1;b<=n;b++)
          for(int c=1;c<=n;c++)
          {
              if ((a!=b)&&(a!=c)&&(b!=c))
              {
                 printf("%d %d %d\n",a,b,c);
              }
          }
  
      //1234 全排列
      n=4;
      printf("1,2,3,4的全排列为:\n");
      for(int a=1;a<=n;a++)
        for(int b=1;b<=n;b++)
          for(int c=1;c<=n;c++)
            for(int i=1;i<=n;i++)
            {
              if ((a!=b)&&(a!=c)&&(a!=i)&&
                   (b!=c)&&(b!=i)&&
                    (c!=i))
              {
                 printf("%d %d %d %d\n",a,b,c,i);
              }
            }
      return 0;
  }
  ```

### 3.火柴棍公式

* **题目描述**:
  `n`根火柴棍，可以拼出多少个形如`A+B=C`的等式？
  
  等式中的`A、B、C`是用火柴棍拼出的整数（若该数非零，则最高位不能是0）。
  
* 摆放如下图所示

  ```
   ——       ——    ——            ——     ——          ——    ——
  |  |  |     |     |   |  |   |      |      ——   |  |  |  |
  |  |  |   ——    ——     ——     ——     ——      |   ——    ——
   ——      |        |      |      |   |  |     |  |  |     |
            ——    ——            ——     ——          ——    ——
  ```

* **注意**:

  **加号**与**等号**各自需要**两根**火柴棍

  如果**A≠B**，则A+B=C与B+A=C视为**不同的等式**

  n根火柴棍必须**全部用上**

* **输入格式**
  一个整数**n**(n<=24)

  **输出格式**
  能拼成的不同等式的**数目**

  **例如**:
  输入`18`   
  得到`9`
  
  **9个等式**：
  
  ```c
  0+4=4
  0+11=11
  1+10=11
  2+2=4
  2+7=9
  4+0=4
  7+2=9
  10+1=11
  11+0=11
  ```
  
* **代码**

  ```c
  #include<stdio.h>
  #include<stdlib.h>
  
  /*
  火柴等式
  思考A或B的最大值
  最多24根火柴，假设全用，除去+=，用了20根火柴
  1摆的火柴最少，所以A或B的最大值是用1凑的
  1最多可以摆10个
  1111+...=比(1111)火柴数要大，符合
  11111+...=比(11111)火柴数要大，已经超过20了
  再分析2222，3333，4444...都不符合
  所以A或B最大为1111
  */
  
  //计算x所需要的个数
  int fun(int x)
  {
      int  num=0;//计数
      //记录0~9所需要的火柴个数
      int f[10]={6,2,5,5,4,5,6,3,7,6};
  
  //为零的时候要特殊考虑
      if (x==0)
          return f[0];
      //例如一个数x为123,分解成1，2，3    
      while (x)
      {
          int rem=x%10;//取余数，3，2
          num+=f[rem];//累加
          x/=10;//去掉末尾，12，1
      }
      
      return num;//返回总个数
  }
  int main()
  {
      int sum;//计数
      int m;
      int c;
      scanf("%d",&m);//读入火柴个数
      //开始枚举AB
      for(int a=0;a<=1111;a++)
        for(int b=0;b<=1111;b++)
        {
          c=a+b;
          if (fun(a)+fun(b)+fun(c)+4==m)
          {
              printf("%d+%d=%d\n",a,b,c);
              sum++;
          }
          
        }
      printf("the type is %d",sum);
  
  }
  ```
